import 'package:hive/hive.dart'; // Import Hive package for local storage.
import 'package:path_provider/path_provider.dart'; // Import for getting the app's directory on the device.

part 'hive.g.dart'; // Necessary for Hive type adapters. The file 'hive.g.dart' will be generated by Hive.

@HiveType(typeId: 0)
class User extends HiveObject {
  @HiveField(0)
  late String username; // Stores the username of the user.

  @HiveField(1)
  late String password; // Stores the user's password.

  @HiveField(2)
  late bool loginStatus; // Tracks whether the user is logged in or not.

  @HiveField(3)
  late int invoiceNumber; // Stores the user's last invoice number.

  // Constructor with named parameters to initialize the User object.
  User({
    required this.username,
    required this.password,
    this.loginStatus = false, // Default login status is false (not logged in).
    this.invoiceNumber = 0, // Default invoice number is 0.
  });
}

@HiveType(typeId: 1)
class Pizza extends HiveObject {
  @HiveField(0)
  late String name; // Name of the pizza.

  @HiveField(1)
  late num smallPrice; // Price for a small pizza.

  @HiveField(2)
  late num mediumPrice; // Price for a medium pizza.

  @HiveField(3)
  late num largePrice; // Price for a large pizza.

  @HiveField(4)
  late String image; // URL or path to the pizza image.

  @HiveField(5)
  late String
      username; // Username associated with this pizza (could be used for tracking orders).
}

@HiveType(typeId: 2)
class Invoice extends HiveObject {
  @HiveField(0)
  late int invoiceNumber; // Unique number for each invoice.

  @HiveField(1)
  late String customerName; // Name of the customer.

  @HiveField(2)
  late String date; // Date of the invoice.

  @HiveField(3)
  late String time; // Time of the invoice.

  @HiveField(4)
  late double totalAmount; // Total amount for the invoice.

  @HiveField(5)
  late num discount; // Discount applied to the invoice.

  @HiveField(6)
  late String items; // List of items in the invoice as a string.

  @HiveField(7)
  late String username; // Username associated with the invoice.
}

class HiveDb {
  static final HiveDb _instance = HiveDb
      ._internal(); // Singleton pattern to ensure only one instance of HiveDb exists.

  // Factory constructor to return the same instance every time.
  factory HiveDb() {
    return _instance;
  }

  // Private internal constructor for the singleton pattern.
  HiveDb._internal();
  // Method to initialize the Hive database.
    Future<void> initializeDatabase() async {
//   await Hive.initFlutter();  // For mobile platforms and web platform, we need to initialize Hive.

//======================================================================================================
    // For desktop platforms, we need to initialize Hive.
    // final directory =  await getApplicationSupportDirectory(); // Get the app's directory.
    // Hive.init(directory.path); // Initialize Hive with the app's directory.
//======================================================================================================

    // Register the Hive adapters for User, Pizza, and Invoice models.
    Hive.registerAdapter(UserAdapter());
    Hive.registerAdapter(PizzaAdapter());
    Hive.registerAdapter(InvoiceAdapter());

    // Open Hive boxes (databases) for users, pizzas, and invoices.
    await Hive.openBox<User>('users');
    await Hive.openBox<Pizza>('pizzas');
    await Hive.openBox<Invoice>('invoices');
  }

  // Method to delete all boxes and recreate the database (useful for resetting data).
  Future<void> deleteAndRecreateDatabase() async {
    await Hive.close(); // Close all Hive boxes before deletion.
    await Hive.deleteBoxFromDisk('users'); // Delete the 'users' box from disk.
    await Hive.deleteBoxFromDisk(
        'pizzas'); // Delete the 'pizzas' box from disk.
    await Hive.deleteBoxFromDisk(
        'invoices'); // Delete the 'invoices' box from disk.
    await initializeDatabase(); // Reinitialize the database after deletion.
  }

  // Method to insert a new user. Returns 1 if successful, 0 if the user already exists.
  Future<int> insertUser(String username, String password) async {
    final usersBox = Hive.box<User>('users');
    if (usersBox.containsKey(username)) {
      return 0; // User already exists.
    }
    final newUser = User(
        username: username, password: password); // Create a new User object.
    await usersBox.put(
        username, newUser); // Save the new user to the 'users' box.
    return 1; // Return success.
  }

  // Method to get a user by username and password. Returns the user if found, otherwise null.
  Future<User?> getUser(String username, String password) async {
    final usersBox = Hive.box<User>('users');
    final user = usersBox.get(username);
    if (user != null && user.password == password) {
      return user; // Return user if credentials match.
    }
    return null; // Return null if user not found or password is incorrect.
  }

  // Method to save an invoice to the 'invoices' box.
  Future<void> saveInvoice(Map<String, dynamic> invoiceData) async {
    final invoicesBox = Hive.box<Invoice>('invoices');
    final invoice = Invoice()
      ..invoiceNumber = invoiceData['invoice_number']
      ..customerName = invoiceData['customer_name']
      ..date = invoiceData['date']
      ..time = invoiceData['time']
      ..totalAmount = invoiceData['total_amount']
      ..discount =
          invoiceData['discount'] ?? 0 // Use 0 as default if no discount.
      ..items = invoiceData['items']
      ..username = invoiceData['username'];
    await invoicesBox.add(invoice); // Add the invoice to the 'invoices' box.
  }

  // Method to read all invoices and return them as a list of maps.
  Future<List<Map<String, dynamic>>> readData() async {
    final invoicesBox = Hive.box<Invoice>('invoices');
    return invoicesBox.values
        .map((invoice) => {
              'invoice_number': invoice.invoiceNumber,
              'customer_name': invoice.customerName,
              'date': invoice.date,
              'time': invoice.time,
              'total_amount': invoice.totalAmount,
              'discount': invoice.discount,
              'items': invoice.items,
              'username': invoice.username,
            })
        .toList();
  }

  // Method to update a user's login status.
  Future<void> updateUserStatus(String username, bool status) async {
    final usersBox = Hive.box<User>('users');
    final user = usersBox.get(username);
    if (user != null) {
      user.loginStatus = status; // Update the login status.
      await user.save(); // Save the updated user.
    }
  }

  // Method to delete a user by username.
  Future<void> deleteUser(String username) async {
    final usersBox = Hive.box<User>('users');
    await usersBox.delete(username); // Delete the user from the 'users' box.
  }

  // Method to get the next invoice number for a user. Increments the invoice number and saves it.
  Future<int?> getNextInvoiceNumber(String username) async {
    final usersBox = Hive.box<User>('users');
    final user = usersBox.get(username);
    if (user != null) {
      user.invoiceNumber++; // Increment the invoice number.
      await user.save(); // Save the updated user.
      return user.invoiceNumber; // Return the new invoice number.
    }
    return null; // Return null if user not found.
  }
}
/*
! Suggestions for Changes or Enhancements:
* Encryption: If you're storing sensitive data like passwords, consider encrypting them using Hive's built-in encryption support. You can generate an encryption key and use it when opening the Hive box.

* Validation: Add validation logic when inserting or retrieving users to ensure data integrity (e.g., checking password complexity).

* Error Handling: Introduce more robust error handling, especially in database operations. For example, handle cases where the database might fail to open or a record might fail to save.

* Asynchronous Loading: Consider using asynchronous operations more effectively, like showing a loading spinner while waiting for database operations to complete.

* Separation of Concerns: You might want to separate your data models (e.g., User, Pizza, Invoice) from your database operations (HiveDb) into different files for better code organization and maintainability.

* Test Coverage: Implement unit tests for your HiveDb methods to ensure that your database logic works correctly, especially for critical operations like user authentication and invoice management.

! Additional Features:

* User Authentication: If you plan to expand the app, consider integrating a more robust authentication method, like OAuth or Firebase Authentication.
* Data Migration: If you need to update your data models in the future, consider implementing data migration strategies to handle changes in the structure of your Hive objects.
* Box Management: Instead of hardcoding box names ('users', 'pizzas', 'invoices'), you can define them as constants to avoid typos and make it easier to manage box names across your app.
 */